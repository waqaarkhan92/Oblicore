/**
 * Detect Breaches and Trigger Alerts Job
 * Detects compliance breaches (deadlines passed without completion) and SLA misses
 * Reference: docs/specs/41_Backend_Background_Jobs.md Section 13.2
 */

import { Job } from 'bullmq';
import { supabaseAdmin } from '@/lib/supabase/server';
import { getAppUrl } from '@/lib/env';
import { deadlineService } from '@/lib/services/deadline-service';
import { evidenceService } from '@/lib/services/evidence-service';
import { userService } from '@/lib/services/user-service';

export interface DetectBreachesAndAlertsJobInput {
  company_id?: string;
  batch_size?: number;
}

export async function processDetectBreachesAndAlertsJob(
  job: Job<DetectBreachesAndAlertsJobInput>
): Promise<void> {
  const { company_id, batch_size = 500 } = job.data;

  try {
    // Step 1: Query breached deadlines (regulatory deadline passed)
    const breachedDeadlines = await deadlineService.getBreached({
      company_id,
      limit: batch_size
    });

    let notificationsCreated = 0;
    let deadlinesMarked = 0;

    // Process each breached deadline
    if (breachedDeadlines && breachedDeadlines.length > 0) {
      for (const deadline of breachedDeadlines) {
        try {
          const obligation = (deadline.obligations as any);
          const site = (obligation?.sites as any);
          const company = (obligation?.companies as any);

          if (!obligation) continue;

          const dueDate = new Date(deadline.due_date);
          const now = new Date();
          const daysOverdue = Math.floor((now.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24));

          // Step 2: Check for missing evidence
          const hasEvidence = await evidenceService.hasApprovedEvidence(obligation.id);

          // Determine notification type
          const notificationType = hasEvidence
            ? 'COMPLIANCE_BREACH_DETECTED'
            : 'REGULATORY_DEADLINE_BREACH';

          const severity = 'CRITICAL';

          // Get recipients (assignee + managers + admins)
          const assignee = obligation.assigned_to
            ? await userService.getById(obligation.assigned_to)
            : null;

          const managers = await userService.getAdminsAndOwners(obligation.company_id);

          const recipients = [
            assignee,
            ...managers
          ].filter(Boolean);

          // Generate action URL
          const baseUrl = getAppUrl();
          const actionUrl = `${baseUrl}/sites/${obligation.site_id}/obligations/${obligation.id}`;

          // Create notifications
          const notifications = recipients.map((recipient: any) => ({
            user_id: recipient.id,
            company_id: obligation.company_id,
            site_id: obligation.site_id,
            recipient_email: recipient.email,
            notification_type: notificationType,
            channel: severity === 'CRITICAL' ? 'EMAIL, SMS, IN_APP' : 'EMAIL, IN_APP',
            priority: 'CRITICAL',
            severity: 'CRITICAL',
            subject: `Compliance Breach: ${obligation.summary || 'Deadline Overdue'}`,
            body_text: `The obligation "${obligation.summary || 'Unknown'}" at ${site?.site_name || 'Unknown Site'} is ${daysOverdue} day(s) overdue. ${hasEvidence ? 'Evidence is linked but deadline has passed.' : 'Required evidence has not been provided.'}`,
            body_html: null, // Will be generated by notification service
            variables: {
              obligation_title: obligation.summary,
              obligation_id: obligation.id,
              deadline_id: deadline.id,
              deadline_date: deadline.due_date,
              days_overdue: daysOverdue,
              site_name: site?.site_name || 'Unknown',
              company_name: company?.name || 'Unknown',
              action_url: actionUrl,
            },
            entity_type: 'deadline',
            entity_id: deadline.id,
            obligation_id: obligation.id,
            action_url: actionUrl,
            status: 'PENDING',
            scheduled_for: new Date().toISOString(),
          }));

          if (notifications.length > 0) {
            const { error: notifyError } = await supabaseAdmin
              .from('notifications')
              .insert(notifications);

            if (notifyError) {
              console.error(`Failed to create notifications for deadline ${deadline.id}:`, notifyError);
              continue;
            }

            notificationsCreated += notifications.length;
          }

          // Mark notification as sent
          await supabaseAdmin
            .from('deadlines')
            .update({
              breach_notification_sent: true,
              breach_detected_at: new Date().toISOString(),
            })
            .eq('id', deadline.id);

          deadlinesMarked++;
        } catch (error: any) {
          console.error(`Error processing deadline ${deadline.id}:`, error);
          continue;
        }
      }
    }

    // Step 5: Detect SLA misses (SLA target date passed)
    const slaMisses = await deadlineService.getSLABreached({
      company_id,
      limit: batch_size
    });

    let slaNotificationsCreated = 0;

    if (slaMisses && slaMisses.length > 0) {
      for (const deadline of slaMisses) {
        try {
          const obligation = (deadline.obligations as any);
          const site = (obligation?.sites as any);
          const company = (obligation?.companies as any);

          if (!obligation) continue;

          const slaTargetDate = new Date(deadline.sla_target_date!);
          const now = new Date();
          const slaBreachHours = Math.floor((now.getTime() - slaTargetDate.getTime()) / (1000 * 60 * 60));

          // Mark SLA as breached
          await deadlineService.markSLAAsBreached(deadline.id);

          // Get recipients
          const managers = await userService.getAdminsAndOwners(obligation.company_id);

          const baseUrl = getAppUrl();
          const actionUrl = `${baseUrl}/sites/${obligation.site_id}/obligations/${obligation.id}`;

          // Create SLA breach notifications
          const slaNotifications = managers.map((manager: any) => ({
            user_id: manager.id,
            company_id: obligation.company_id,
            site_id: obligation.site_id,
            recipient_email: manager.email,
            notification_type: 'SLA_BREACH_DETECTED',
            channel: 'EMAIL, IN_APP',
            priority: slaBreachHours > 24 ? 'URGENT' : 'HIGH',
            severity: slaBreachHours > 48 ? 'CRITICAL' : slaBreachHours > 24 ? 'WARNING' : 'INFO',
            subject: `SLA Breach: ${obligation.summary || 'Deadline'}`,
            body_text: `The internal SLA target for "${obligation.summary || 'Unknown'}" has been breached by ${slaBreachHours} hour(s).`,
            body_html: null,
            variables: {
              deadline_title: obligation.summary,
              deadline_id: deadline.id,
              obligation_id: obligation.id,
              site_name: site?.site_name || 'Unknown',
              company_name: company?.name || 'Unknown',
              sla_target_date: deadline.sla_target_date,
              sla_breach_hours: slaBreachHours,
              action_url: actionUrl,
            },
            entity_type: 'deadline',
            entity_id: deadline.id,
            obligation_id: obligation.id,
            action_url: actionUrl,
            status: 'PENDING',
            scheduled_for: new Date().toISOString(),
          }));

          if (slaNotifications.length > 0) {
            const { error: notifyError } = await supabaseAdmin
              .from('notifications')
              .insert(slaNotifications);

            if (!notifyError) {
              slaNotificationsCreated += slaNotifications.length;
            }
          }
        } catch (error: any) {
          console.error(`Error processing SLA miss ${deadline.id}:`, error);
          continue;
        }
      }
    }

    console.log(
      `Breach detection completed: ${deadlinesMarked} deadlines marked, ${notificationsCreated} breach notifications, ${slaNotificationsCreated} SLA breach notifications`
    );
  } catch (error: any) {
    console.error('Error in breach detection job:', error);
    throw error;
  }
}

