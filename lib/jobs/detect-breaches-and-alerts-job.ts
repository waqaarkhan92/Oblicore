/**
 * Detect Breaches and Trigger Alerts Job
 * Detects compliance breaches (deadlines passed without completion) and SLA misses
 * Reference: docs/specs/41_Backend_Background_Jobs.md Section 13.2
 */

import { Job } from 'bullmq';
import { supabaseAdmin } from '@/lib/supabase/server';
import { getAppUrl } from '@/lib/env';

export interface DetectBreachesAndAlertsJobInput {
  company_id?: string;
  batch_size?: number;
}

export async function processDetectBreachesAndAlertsJob(
  job: Job<DetectBreachesAndAlertsJobInput>
): Promise<void> {
  const { company_id, batch_size = 500 } = job.data;

  try {
    // Step 1: Query breached deadlines (regulatory deadline passed)
    let breachedQuery = supabaseAdmin
      .from('deadlines')
      .select(`
        id,
        obligation_id,
        due_date,
        status,
        sla_target_date,
        sla_breached_at,
        breach_notification_sent,
        obligations!inner(
          id,
          summary,
          assigned_to,
          site_id,
          company_id,
          sites!inner(id, site_name),
          companies!inner(id, name)
        )
      `)
      .eq('status', 'OVERDUE')
      .lt('due_date', new Date().toISOString())
      .eq('breach_notification_sent', false)
      .order('due_date', { ascending: true })
      .limit(batch_size);

    if (company_id) {
      breachedQuery = breachedQuery.eq('company_id', company_id);
    }

    const { data: breachedDeadlines, error: breachedError } = await breachedQuery;

    if (breachedError) {
      throw new Error(`Failed to fetch breached deadlines: ${breachedError.message}`);
    }

    let notificationsCreated = 0;
    let deadlinesMarked = 0;

    // Process each breached deadline
    if (breachedDeadlines && breachedDeadlines.length > 0) {
      for (const deadline of breachedDeadlines) {
        try {
          const obligation = (deadline.obligations as any);
          const site = (obligation?.sites as any);
          const company = (obligation?.companies as any);

          if (!obligation) continue;

          const dueDate = new Date(deadline.due_date);
          const now = new Date();
          const daysOverdue = Math.floor((now.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24));

          // Step 2: Check for missing evidence
          const { data: evidenceLinks } = await supabaseAdmin
            .from('obligation_evidence_links')
            .select('evidence_id')
            .eq('obligation_id', obligation.id);

          const { data: approvedEvidence } = await supabaseAdmin
            .from('evidence_items')
            .select('id')
            .in('id', (evidenceLinks || []).map((l: any) => l.evidence_id))
            .eq('is_archived', false)
            .eq('validation_status', 'APPROVED');

          const hasEvidence = approvedEvidence && approvedEvidence.length > 0;

          // Determine notification type
          const notificationType = hasEvidence
            ? 'COMPLIANCE_BREACH_DETECTED'
            : 'REGULATORY_DEADLINE_BREACH';

          const severity = 'CRITICAL';

          // Get recipients (assignee + managers + admins)
          const { data: assignee } = await supabaseAdmin
            .from('users')
            .select('id, email, full_name')
            .eq('id', obligation.assigned_to)
            .single();

          const { data: managers } = await supabaseAdmin
            .from('users')
            .select('id, email, full_name')
            .eq('company_id', obligation.company_id)
            .in('id', await getRoleUserIds(obligation.company_id, ['ADMIN', 'OWNER']));

          const recipients = [
            assignee,
            ...(managers || [])
          ].filter(Boolean);

          // Generate action URL
          const baseUrl = getAppUrl();
          const actionUrl = `${baseUrl}/sites/${obligation.site_id}/obligations/${obligation.id}`;

          // Create notifications
          const notifications = recipients.map((recipient: any) => ({
            user_id: recipient.id,
            company_id: obligation.company_id,
            site_id: obligation.site_id,
            recipient_email: recipient.email,
            notification_type: notificationType,
            channel: severity === 'CRITICAL' ? 'EMAIL, SMS, IN_APP' : 'EMAIL, IN_APP',
            priority: 'CRITICAL',
            severity: 'CRITICAL',
            subject: `Compliance Breach: ${obligation.summary || 'Deadline Overdue'}`,
            body_text: `The obligation "${obligation.summary || 'Unknown'}" at ${site?.site_name || 'Unknown Site'} is ${daysOverdue} day(s) overdue. ${hasEvidence ? 'Evidence is linked but deadline has passed.' : 'Required evidence has not been provided.'}`,
            body_html: null, // Will be generated by notification service
            variables: {
              obligation_title: obligation.summary,
              obligation_id: obligation.id,
              deadline_id: deadline.id,
              deadline_date: deadline.due_date,
              days_overdue: daysOverdue,
              site_name: site?.site_name || 'Unknown',
              company_name: company?.name || 'Unknown',
              action_url: actionUrl,
            },
            entity_type: 'deadline',
            entity_id: deadline.id,
            obligation_id: obligation.id,
            action_url: actionUrl,
            status: 'PENDING',
            scheduled_for: new Date().toISOString(),
          }));

          if (notifications.length > 0) {
            const { error: notifyError } = await supabaseAdmin
              .from('notifications')
              .insert(notifications);

            if (notifyError) {
              console.error(`Failed to create notifications for deadline ${deadline.id}:`, notifyError);
              continue;
            }

            notificationsCreated += notifications.length;
          }

          // Mark notification as sent
          await supabaseAdmin
            .from('deadlines')
            .update({
              breach_notification_sent: true,
              breach_detected_at: new Date().toISOString(),
            })
            .eq('id', deadline.id);

          deadlinesMarked++;
        } catch (error: any) {
          console.error(`Error processing deadline ${deadline.id}:`, error);
          continue;
        }
      }
    }

    // Step 5: Detect SLA misses (SLA target date passed)
    let slaQuery = supabaseAdmin
      .from('deadlines')
      .select(`
        id,
        obligation_id,
        sla_target_date,
        sla_breached_at,
        obligations!inner(
          id,
          summary,
          site_id,
          company_id,
          sites!inner(id, site_name),
          companies!inner(id, name)
        )
      `)
      .not('sla_target_date', 'is', null)
      .lt('sla_target_date', new Date().toISOString())
      .is('sla_breached_at', null)
      .neq('status', 'COMPLETED')
      .order('sla_target_date', { ascending: true })
      .limit(batch_size);

    if (company_id) {
      slaQuery = slaQuery.eq('company_id', company_id);
    }

    const { data: slaMisses, error: slaError } = await slaQuery;

    if (slaError) {
      console.error('Failed to fetch SLA misses:', slaError);
    }

    let slaNotificationsCreated = 0;

    if (slaMisses && slaMisses.length > 0) {
      for (const deadline of slaMisses) {
        try {
          const obligation = (deadline.obligations as any);
          const site = (obligation?.sites as any);
          const company = (obligation?.companies as any);

          if (!obligation) continue;

          const slaTargetDate = new Date(deadline.sla_target_date!);
          const now = new Date();
          const slaBreachHours = Math.floor((now.getTime() - slaTargetDate.getTime()) / (1000 * 60 * 60));

          // Mark SLA as breached
          await supabaseAdmin
            .from('deadlines')
            .update({
              sla_breached_at: now.toISOString(),
              sla_breach_duration_hours: 0,
            })
            .eq('id', deadline.id);

          // Get recipients
          const { data: managers } = await supabaseAdmin
            .from('users')
            .select('id, email, full_name')
            .eq('company_id', obligation.company_id)
            .in('id', await getRoleUserIds(obligation.company_id, ['ADMIN', 'OWNER']));

          const baseUrl = getAppUrl();
          const actionUrl = `${baseUrl}/sites/${obligation.site_id}/obligations/${obligation.id}`;

          // Create SLA breach notifications
          const slaNotifications = (managers || []).map((manager: any) => ({
            user_id: manager.id,
            company_id: obligation.company_id,
            site_id: obligation.site_id,
            recipient_email: manager.email,
            notification_type: 'SLA_BREACH_DETECTED',
            channel: 'EMAIL, IN_APP',
            priority: slaBreachHours > 24 ? 'URGENT' : 'HIGH',
            severity: slaBreachHours > 48 ? 'CRITICAL' : slaBreachHours > 24 ? 'WARNING' : 'INFO',
            subject: `SLA Breach: ${obligation.summary || 'Deadline'}`,
            body_text: `The internal SLA target for "${obligation.summary || 'Unknown'}" has been breached by ${slaBreachHours} hour(s).`,
            body_html: null,
            variables: {
              deadline_title: obligation.summary,
              deadline_id: deadline.id,
              obligation_id: obligation.id,
              site_name: site?.site_name || 'Unknown',
              company_name: company?.name || 'Unknown',
              sla_target_date: deadline.sla_target_date,
              sla_breach_hours: slaBreachHours,
              action_url: actionUrl,
            },
            entity_type: 'deadline',
            entity_id: deadline.id,
            obligation_id: obligation.id,
            action_url: actionUrl,
            status: 'PENDING',
            scheduled_for: new Date().toISOString(),
          }));

          if (slaNotifications.length > 0) {
            const { error: notifyError } = await supabaseAdmin
              .from('notifications')
              .insert(slaNotifications);

            if (!notifyError) {
              slaNotificationsCreated += slaNotifications.length;
            }
          }
        } catch (error: any) {
          console.error(`Error processing SLA miss ${deadline.id}:`, error);
          continue;
        }
      }
    }

    console.log(
      `Breach detection completed: ${deadlinesMarked} deadlines marked, ${notificationsCreated} breach notifications, ${slaNotificationsCreated} SLA breach notifications`
    );
  } catch (error: any) {
    console.error('Error in breach detection job:', error);
    throw error;
  }
}

async function getRoleUserIds(companyId: string, roles: string[]): Promise<string[]> {
  const { data: userRoles } = await supabaseAdmin
    .from('user_roles')
    .select('user_id')
    .in('role', roles);

  if (!userRoles) return [];

  const userIds = userRoles.map((ur: any) => ur.user_id);

  const { data: users } = await supabaseAdmin
    .from('users')
    .select('id')
    .eq('company_id', companyId)
    .in('id', userIds);

  return users?.map((u: any) => u.id) || [];
}

